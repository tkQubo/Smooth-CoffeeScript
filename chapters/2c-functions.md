page 44
---

# 関数


プログラムでは、異なる場面で同じ処理が必要になることがあります。同じ命令文を繰り返し書くことは退屈な作業であり、またエラーの温床ともなります。こういった処理を一箇所にまとめ、プログラム実行時に必要に応じて呼び出すことはできないでしょうか？ここで関数が役に立ちます。関数とは、プログラムがいつでも呼び出せるコードの缶詰のようなものです。例えば文字列を画面上に出力するには数行の命令文を書かなければいけません。しかし`show`関数を用いれば`show 'Aleph'`のように簡単にそれを実現できるのです。

いま関数を「コードの缶詰」と表現しましたが、関数の役割はこれだけではありません。純粋関数、アルゴリズム、間接参照、抽象化、意思決定、モジュール、継続、データ構造など、関数は用途に応じて様々な役割を果たすことができます。関数を上手に使いこなすスキルは、プロフェッショナルなプログラマにとっては必要不可欠です。この章では、関数の簡単な説明を行ってゆきます。より細かな内容に関しては[関数プログラミング][]を参照して下さい。

---

まず純粋関数から説明してゆきましょう。純粋関数とは、皆さんがかつて数学の授業で学んだであろう、いわゆる数学の関数のことを指します。コサインや絶対値などの計算処理は、引数が１個の純粋関数にあたります。一方、加算は引数が２個のの純粋関数になります。純粋関数の重要な特徴として、同じ引数を与えた場合に必ず同じ値を返し、決して副作用を持たない、というものがあります。いくつかの引数を取り、それらの値に基づいた計算結果を返す以外に、何も余計なことは行いません。

CoffeeScriptでは、加算は演算子として存在しますが、このように関数でラッピングすることもできます。（これは無意味に見えるかもしれません。しかしあとで実際に役に立つケースを紹介します。）

	add = (a, b) -> a + b
	show add 2, 2 


page 45
---


`add`は関数の名前、そして`a`と`b`が２つの引数の名前です。`a+b`は、関数の本体となります。「`->`」は、新しく関数を作るときに使います。
**変数名に割り当てることで、関数をその名前で保存することができます。**
*ある変数の名前を割り当てたときに、その名前の下に関数が保存されます。*
「`->`」の前には、括弧で囲まれた引数リストがきます。引数を取らない場合は、関数には括弧は必要ありません。「`->`」の後は関数の本体です。関数本体は「`->`」と同じ行に続けてもいいですし、インデントを設定して次以降の行に書いても構いません。関数の最後の命令文は関数の戻り値となります。また、予約語である`return`の後に式を書けば、その式が関数の戻り値になります。 プログラムは`return`文を処理した時点で直ちに関数から抜け出し、その関数の呼び出し元のコードに、計算結果である戻り値を渡すことになります。式の無い`return`文の場合、関数は`undefined`を返します。関数本体には、もちろん複数の命令文を記述することができます。ではここで、自然数のべき乗を求める関数を見てみましょう。

	power = (base, exponent) ->
	  result = 1
	  for count in [0...exponent]
	    result *= base
	  result
	show power 2, 10

`32`ページの練習問題を解かれた方には、このべき乗の計算方法には見覚えがあるはずです。ここでは変数`result`を作り、その値が更新されるという副作用が発生しています。しかし私はつい先ほど、純粋関数には副作用がないと言ったばかりです。これは一体どういうことでしょうか？
**実は関数内で生成された変数は、その関数の中でしか有効ではないのです。**
*実は関数内で生成された変数の有効範囲は、その関数内に限定されているのです。*
そのおかげでプログラマーは、「プログラム内のあらゆる変数にそれぞれ異なった名前をつけなければいけない」などという面倒から開放されるｍｐです。`result`は`power`関数の中でのみ存在し、その値の変化も、関数が戻るまでのみ有効です。従って関数を呼び出したコードの側から見れば、副作用は全く発生していないことになります。

## 練習問題7

引数に数値型を取り、その数値の絶対値を返す関数`absolute`を書いてください。負数の絶対値はその数のマイナス符号を外したもので、正の数あるいは0の絶対値は、その数そのものを指すこととします。


page 46
---


### 解答
	absolute = (number) ->
	  if number < 0
	    -number
	  else
	    number
	show absolute -144

純粋関数には、2つの大きなメリットあります。それは、作るのも再利用するのも簡単だということです。

純粋関数の場合、関数呼び出しをそれ自体で独立した一つの塊として見なすことができます。もし関数が正しく動作しているか確信がもてない場合、コンソール画面から直接呼び出してテストすることができます。コンテクスト文脈に依存しない分、動作確認がシンプルになります[^10]。
テストを自動化するのも簡単です。テスト対象の関数を呼び出すプログラムを書くだけなのですから。非-純粋関数の場合は様々な条件で異なった値を返し、テストや検証を困難にする副作用を引き起こします。

純粋関数はそれ自身で完結しているため、非-純粋関数に比べて利用価値が高く、様々なシチュエーションで関連してきます。例えば`show`を見てみましょう。この便利な関数は、スクリーン上に出力表示用の領域を必要とします。この領域が無ければ、関数は何の役にも立ちません。さてここで`format`と呼ばれる関数を考えてみましょう。これの関数は一つの値を引数に取り、その値を表す文字列型を返します。この関数は`show`よりも多くのシチュエーションで使えます。

しかしもちろん`format`は`show`と同じ問題を解決できるわけではありません。`show`の機能は副作用を必要とするため、いかなる純粋関数にもその機能を実現できないのです。多くの場合、問題解決には非-純粋関数を使います。純粋関数で解決できる問題もありますが、非-純粋関数の方がはるかに便利で効率的なものになります。

[^10]: 厳密に言えば、純粋関数はいかなる外部変数も利用することができません。外部変数は値が変わるかもしれませんし、もし値が変われば、同じ引数でも異なる戻り値を得る可能性があるからです。実際の場面では、プログラマーは幾つかの値を変更されることのない「定数」として扱い、この定数のみを利用した関数を純粋関数に含めています。関数値を保持した変数など、定数の典型例です。


page 47
---


従って純粋関数で処理できる場面では純粋関数を使ったほうが楽ですが、だからと言って間違っても非純粋関数を毛嫌いしてはいけません。

---

関数が期待した値を返してくれるかどうかは、どうやって確認すべきでしょうか？先ほどの練習問題では`absolute -144`を実行し、正しい答えを得ることができました。シンプルな関数にはこれだけで充分でしょうが、関数というものは一瞬で途方も無く複雑になり、プログラムコードを読みだけでは戻り値を予測するのが困難になってゆきます。`absolute`がちゃんと動いているか確認するには、もっと多くのテストケースが必要です。しかし、ひたすらテストケースを書き続けるばかりではすぐに飽きが来てしまいます。何かいい方法は無いでしょうか…。

練習問題では、関数が果たすべき機能として次のように書かれていました。「負数の絶対値はその数のマイナス符号を外したもので、正の数あるいは0の絶対値は、その数そのものを指すこととします。」この機能を、コンピュータが理解してテストできる「プロパティ」に置き換えてみましょう。

	testAbsolute = (name, property) ->
	  qc.testPure absolute , [qc.arbInt], name, property

関数`testAbsolute`はqc (quick check[^11]を意味します)の`testPure`関数を呼び出し、最初の引数で`absolute`をテストするよう`testPure`に指示しています。次の引数`arbInt`は、`absolute`が「引数に任意の整数値を取ること」を意味しています。角括弧やドット記号は気にしないでください。これらは次章で説明します。`testAbsolute`に分かり易いテスト名とプロパティを与えて呼び出すことにより、`absolute`にどのような挙動を求められているのかを定義することができます。

	testAbsolute 'returns positive integers',
	  (c, arg, result) -> result >= 0

まず関数の説明から、`absolute`が0以上の値を返さなければいけないのは明白です。プロパティ内の`result >= 0`がそのことを意味しています。ここでのプロパティは、「テストケース（`case`が予約語なので変数名には`c`を使っています）」「`absolute`を呼び出す時の引数」「`absolute`の戻り値」の、計３つの引数を取る関数です。

[^11]QuickCheckは元々チャルマース工科大学のKoen ClaessenとJohn HughesがHaskell向けに開発したものですが、他のプログラミング言語用にも次々に再実装されてきています。qcライブラリは、Darrin ThompsonによるJavaScript向けの実装です。CoffeeScript対応版は、preludeに含まれています。


page 48
---


これらの値に応じて、プロパティは「関数が与えられた条件を満たしているかどうか」をtrueあるいはfalseで返します。

関数の説明にはこう書いてあります。「正の数あるいは0の絶対値は、その数そのものを指すこととします。」このプロパティには正の数しか必要ありません。`guard`の呼び出しは、qcに正ではない値を無視するように伝えます。そしてプロパティは戻り値が引数と同じであることをチェックします。

	testAbsolute 'positive returns positive',
	  (c, arg, result) -> c.guard arg >= 0; result is arg

負の数のチェックももほとんど同じで、違いはプロパティ内のマイナス符号だけです。

	testAbsolute 'negative returns positive',
	  (c, arg, result) -> c.guard arg < 0; result is -arg

ここまでの段階では、関数に必要なプロパティが宣言されただけです。テストは何一つ実行していません。`qc.test()`を呼び出せばテスト処理が開始され、qcがテスト用データを生成してプロパティのチェックを行います。

	Pass: returns positive integers (pass=100, invalid=0)
	Pass: positive returns positive (pass=100, invalid=103)
	Pass: negative returns positive (pass=100, invalid=90)

素晴らしいですね。関数`absolute`は一瞬のうちに300ものテストケースをパスしてくれました。ちなみにinvalidの数は、`guard`の呼び出しで無効にされたテストケースの数です。テスト値を表示させたい場合、プロパティ内に`show c.args`を入れて下さい。

一方、テストが失敗した場合はどのように表示されるのでしょうか？ではご期待にお応えして、テストを失敗させる格好の素材として、本章の最初の方でご紹介した`power`を取り上げてみましょう。`power`関数は、標準ライブラリの`Math.pow`関数と同じ動作をするはずです（もちろん整数を対象にとる場合に限りますが）。

	qc.testPure power, [qc.arbInt , qc.arbInt],
	  'power == Math.pow for integers',
	  (c, base, exponent , result) ->
	    result == c.note Math.pow base, exponent

これを確かめるには、まず`testPure`を呼び出し、`power`が「2つの整数を引数として取る」ことを記述しましょう。そしてプロパティに、`power`の計算結果が`Math.pow`のそれと同じであることを示してやればいいのです。また`Math.pow`の戻り値を得るため、`c.note`を呼び出して元々の引数を登録しましょう。


page 49
---


	fail: power == Math.pow for integers
	pass=9, invalid=0
	shrinkedArgs=3,-2,9,0.1111111111111111
	Failed case:
	[ -9,
	  -9,
	  -387420489,
	  -2.581174791713197e-9 ]

このテストは失敗し、qcはその理由を教えてくれます。行の後半に出てくる2つの-9は、qcがテストケース用に生成した引数です。-387420489は、`power`の戻り値です。最後の数値は`Math.pow`関数から得られたもので、-9-9=-1/387420489の近似値になっています。

	qc.testPure power, [qc.arbWholeNum , qc.arbWholeNum],
	  'power == Math.pow for positive integers',
	  (c, base, exponent , result) ->
	  result == c.note Math.pow base, exponent

`power`の対象範囲を整数とするのは、やや広すぎたかもしれません。しかし少なくとも自然数に関しては問題なく動作していたのではないでしょうか？ここで前の例のように`guard`を使ってテストケースの範囲を狭める以外にも、引数の記述を変えるというやり方があります。qcは、引数としてrange型・string型・date型・リスト型など様々な種類の型を扱うことができます。自然数には`arbWholeNum`が用意されています。

	fail: power == Math.pow for positive integers
	pass=28, invalid=0
	shrinkedArgs=9,18,150094635296999100,150094635296999140
	Failed case:
	[ 27,
	  27,
	  4.434264882430377e+38,
	  4.434264882430378e+38 ]

さて今度は28個のテストをパスして、27^27で止まりました。どうやら最後の桁の数字が違っているみたいです[^12]。ここで`shrinkedArgs`と書かれた行に注目してください。qcはテストに失敗すると、同じ問題を発生させるテストの中で、よりシンプルなものを探し出そうとします。ここで言う「シンプル」とはより短い文字列やリストなどのことで、この場合はより小さな数値のことを指します。

[^12]ECMAScriptではJavaScriptに対してこれらの偏差誤差を許容しています。これはもちろんCoffeeScriptにも当てはまります。どうしても完全に誤差の無い整数を扱いたい場合は、サードパーティー製のライブラリを使うか、Pureなどのより数学志向なプログラミング言語を使うことをお勧めします。


page 50
---


qcは9^18の段階で既に違いを見つけています。`power`の戻り値は100で終わり、`Math.pow`は140で終わっています。果たしてどちらが正しいのでしょうか？どちらも正しくありません[^13]。 9^18 = 150094635296999121が正解です。

## 練習問題8

下記のプログラムをコピーして、関数`intensify`がテストプロパティをパスするように修正して下さい。`223`ページのqcリファレンスには`arbConst`など多くのqc用語が載っているので、参考にしてください。またpreludeをrequireすると、`c.noteVerbose`が使えます。`c.noteVerbose`はテスト失敗時に値を記録したり、テスト時に値を表示させたりすることができます。

	require './prelude'

	intensify = (n) ->
	  2

	qc.testPure intensify , [qc.arbInt],
	  'intensify grows by 2 when positive',
	  (c, arg, result) ->
	    c.guard arg > 0
	    arg + 2 == result

	qc.testPure intensify , [qc.arbInt],
	  'intensify grows by 2 when negative',
	  (c, arg, result) ->
	    c.guard arg < 0
	    arg - 2 == result

	qc.testPure intensify , [qc.arbConst(0)],
	  'only non-zero intensify grows',
	  (c, arg, result) ->
	    result is 0

	qc.test()

[^13]: この書籍（訳者注：原版のこと）を作る際LYXと呼ばれる文書プロセッサを使いました。計算結果はLYXに統合されているMaximaによるものです。Maximaは、記号演算や精度制限の無い計算を行うことのできるコンピュータ代数システムです。


page 51
---


### 解答

	intensify = (n) ->
	  if n > 0
	    n + 2
	  else if n < 0
	    n - 2
	  else
	    n

関数を書く前にテスト記述を書くことは、関数を把握するのに役立ちます。今までの例で見たように、テスト記述は、テスト対象である関数よりもかなり長いコードになります。[二分ヒープ][]には、クラスとそのテストケースのより実際的な例が述べられています。このような記述的テストは、テストアルゴリズムおよび再利用可能なライブラリに非常に適しています。他にも好みと作業内容に応じて、さまざまなテストツールが存在します[^14]。ここで強調しておきたいことは、「適切なレベルのテストを行うことは、コーディングの一部である」ということです。

---

関数の話に戻ります。関数は、`return`文は必須ではありません。`return`文無しで関数処理が終わった場合、関数は最後の命令文の値を戻り値とします。preludeの`show`関数は、自身の引数をそのまま返すので、表現式の中で使うことができます。もし`undefined`を返したい場合は、最後の命令文を「`return`」にします。

	yell = (message) ->
	  show message + '!!'
	  return
	yell 'Yow'

---

関数の引数は、内部変数のように利用できます。関数は呼び出し時の引数を参照しますが、これらは内部で定義された他の変数と同様、関数外では利用できません。また関数はトップレベルスコープとは別に、小さなローカルスコープを生成します。変数を参照する際、関数はまず外部スコープをチェックし、そこに変数が見つからない場合のみ、ローカルスコープに変数を生成します。

[^14]: CoffeeScriptはほとんどのJavaScript用テストツールに対して互換性があり、簡単に利用することができます。


page 52
---


	dino = '恐竜：生きてるよ！'
	reptile = 'トカゲ：元気だぜ！'
	meteor = (reptile) ->
	  show reptile 				# 引数
	  dino = '恐竜：絶滅した！'
	  reptile = 'トカゲ：生き残った！'
	  possum = 'オポッサム：はじめまして！'
	show dino 					# 外部
	meteor '何が起こった？'
	show dino					# 外部 変更あり
	show reptile				# 外部 変更無し
	try show possum catch e
	  show e.message			# undefinedエラー

これによって、引数は同じ名前を持つ外部変数を「隠蔽する」ことができます。変数を扱うのに一番楽な方法は、ファイル内で全ての変数にユニークな名前を付けることです。また明示的にエクスポートしない限り、トップレベル変数はファイル間で共有されません。詳しくは[モジュラー性][]を参照して下さい。

![FIG52][]

従って関数内部の変数名が外部スコープにも存在した場合、その変数は外部スコープを参照しているものであって、新しく定義されたものではありません。`variable = 'ほげほげ'`のような表現式は、新しい変数の定義かもしれませんし、あるいは既存の変数に代入しているだけかも知れません。


page 53
---

トップレベル変数を使う場合には、ファイルの先頭部分でその変数を宣言してデフォルト値を与えておくのが、理想的なやり方です。


	variable = '1番目' 				# 定義

	showVariable = ->
	  show 'showVariableでのvariableの値: ' +
	        variable 				# 2番目

	test = ->
	  variable = '2番目' 			# 代入
	  show 'testでのvariableの値: ' +
	        variable	 			# 2番目
	  showVariable()

	show 'variable: ' + variable 	# 1番目
	test()
	show 'variable: ' + variable 	# 2番目


ローカルスコープで定義された変数は、関数内のコードからしか利用できません。関数がさらに別の関数を呼び出した場合、新しく呼び出された関数からは、呼び出し元のローカルスコープ変数が見えないのです。

	andHere = ->
	  try show aLocal # 未定義
	  catch e then show e.message
	isHere = ->
	  aLocal = 'aLocalは定義済み'
	  andHere()
	isHere()

ここで一つ、些細ではありますが極めて役立つ仕組みを紹介しておきます。それは「関数が別の関数*内部*で定義された場合、内側の関数のローカルスコープは、それを囲むローカルスコープをベースにする」ということです。

	isHere = ->
	  andHere = ->
	    try show aLocal # 定義済み
	    catch e then show e.message
	  aLocal = 'aLocal is defined'
	  andHere()
	isHere()


page 54
---


さらにこのケースをご覧ください。きっとびっくりすると思います。

	varWhich = 'トップレベル'
	parentFunction = ->
	  varWhich = 'ローカル'
	  childFunction = ->
	    show varWhich
	  childFunction
	child = parentFunction()
	child()

関数`parentFunction`は*内部関数を返し*、最終行でその関数を呼び出しています。`parentFunction`はこの時点でとっくに処理を終えていますが、`varWhich`が値「`ローカル`」を保持したローカルスコープはまだ残っています。従って関数`childFunction`はその値を参照するわけです。この仕組みをクロージャと呼びます。

---

スコープを使うことによって、関数を「統合する」ことができます。内部関数が、自身を包括する関数内の変数を使うことによって、さまざまな処理が可能になります。例えば引数に2を足す関数、5を足す関数などのように、機能的にはほとんど同一の関数を考えてみてください。

	makeAddFunction = (amount) ->
	  add = (number) -> number + amount

	addTwo = makeAddFunction 2
	addFive = makeAddFunction 5
	show addTwo(1) + addFive(1)

---

スコープ化の法則により、異なる関数が同じ名前の変数を使っても衝突せず、さらに関数が*自分自身*を呼び出しても何の問題も生じないのです。関数が自分自身を呼び出すことを、再帰と呼びます。再帰関数は少々変わった定義の仕方をします。再帰関数を定義するにはまず停止条件が必要です。さもなければせっかく丁寧に作った再帰関数も、無限ループに陥ることになります。この`power`関数を見てください。


page 55
---


	powerRec = (base, exponent) ->
	  if exponent == 0
	    1
	  else
	    base * powerRec base, exponent - 1
	show 'power 3, 3 = ' + powerRec 3, 3

これは数学者が定義した「べき乗」に近く、以前のバージョンよりもはるかに良いコードに見えます。これはある種のループではありますが、`while`も`for`も無く、さらにはローカルな副作用も存在しません。関数は自分自身を呼び出して、同じ処理を繰り返します。自分自身を呼び出す事で、関数は同じ効果を得る事ができます。停止条件は変数`exponent`が0になることであり、関数は呼び出しのたびに`exponent`から1を引き算して0に近づけてゆきます。もし`powerRec`を再利用可能なライブラリ化した場合、`exponent`が自然数であるという前提条件を明確にドキュメント化しなければいけません。

---

コードを簡潔にすることで、パフォーマンスに影響が出てくるでしょうか？それを確かめるには、方法は一つしかありません。実際に計測してみることです。下に挙げたのは筆者のPCによる実行結果です。あくまでも一例としてお考えください。CPU、オペレーティングシステム、コンパイラー、ブラウザのインタープリタなどの全てがパフォーマンスに影響してきます。ですので可能な限りターゲット環境に近い状況で計測してください。

	timeIt = (func) ->
	  start = new Date()
	  for i in [0...1000000] then func()
	  show "Timing: #{(new Date() - start)*0.001}s"

	timeIt -> p = add 9,18			# 0.042s
	timeIt -> p = Math.pow 9,18		# 0.049s
	timeIt -> p = power 9,18		# 0.464s
	timeIt -> p = powerRec 9,18		# 0.544s

実行速度とコードのエレガントさとのトレードオフは、考慮すべきテーマです。この問題は、再帰関数を採用するか否かという場面に限らず出てきます。多くの場合、読み易く直感的かつコンパクトな解法を、より複雑でしかし早い解法で置き換えることがあります。

先に出てきた`power`関数はエレガントではないものの、十分にシンプルで読み易くなっています。これを再帰版に代えることは、あまり意味があるとは言えません。一方でプログラムの扱う内容があまりに複雑化した場合は、多少の効率性を捨ててプログラムを簡略化する方がいいかもしれません。


page 56
---


多くのプログラマが繰り返し指摘していますが、「プログラムの速度がよほど遅いのでない限り、効率性の心配なんてしなくていい」という基本ルールがあります。筆者もこれには大いに賛成します。仮に修正が必要になったら、どの部分がネックになっているのかを見つけ出し、そのエレガントなコードを効率的なものへと替えてゆきましょう。もちろんこのルールは、パフォーマンスを完全に無視してコーディングを進めてもいいという意味ではありません。関数`power`に見られるように、「エレガントな」アプローチでもそれほどシンプルにならないというケースが良くあります。一方で熟練プログラマは、シンプルなアプローチが決して早くはならないことを一瞬で見抜きます。

私がこの問題を口を酸っぱくして言い続けるのも、あまりに多くのプログラマが、誤った考えに基づいて、取るに足らない些細な効率性を重視しすぎているからです。

その結果、巨大でより複雑な、そしてしばしば正確さに欠けたプログラムが誕生します。素直な書き方よりも時間をかけた割には、大した速度向上も望めない代物です。

もしシンプルで正しい実装ではあるもののあまりにも遅いコードがあった場合、それは改良版をテストする時の参考として使うことができます。まず第一に考えなければいけないこと、それは、直面している問題を扱うにはどのようなデータ構造やアルゴリズムが必要かということです。例えば10の要素が入ったリストを検索するのと100万個の要素が入ったリストを検索するのでは、大きな違いがあります。この種の問題は、[検索][]でより深く掘り下げられています。

---

ところで、筆者は再帰について話していました。再帰と深く関係のある概念の一つに、スタックというものがあります。まず関数が呼ばれたときは、コントロール制御は関数本体に渡されます。そして関数本体から戻るときに、関数を呼び出した側のコード処理が再開します。関数本体の実行中、コンピュータは関数を呼び出したコンテクストを保持し、その後の処理の続行に備えておかなければいけません。コンテクストが保存される場所は、スタックと呼びます。

「スタック」（訳者注：日本語で「積み重ね」の意味）と呼ばれるには理由があります。これまで見てきたの通り、関数本体は他の関数を呼び出すことができます。関数が呼ばれるたびに、コンテクストをその都度保存しなければいけません。これを、コンテクストが積み重なってゆくイメージとして捉えてみて下さい。関数が呼ばれるたびに、現在のコンテクストがスタックの一番上に置かれます。関数が戻ったとき、一番上のスタックが取り除かれ処理が再開されます。

スタックはコンピュータのメモリ上に保存されます。スタックが大きくなりすぎたとき、コンピュータは「スタックスペースが足りません」や「再帰が多すぎます」などのエラーメッセージを表示します。ですので再帰関数を書く際には、必ずスタックの存在を念頭に入れておいて下さい。


page 57
---


	chicken = ->
	  show 'ニワトリ'
	  egg()
	egg = ->
	  show 'タマゴ'
	  chicken()
	try show chicken() + 'が先です'
	catch error then show error.message

これは間違ったプログラムの書き方ですが、実に面白い特徴があります。この例は、関数が再帰的であるためには、必ずしも自分自身を直接呼び出さなくても良いということを示しています。直接的であれ間接的であれ、別の関数が最初の関数を再び呼び出せば、これは立派な再帰といえます。`try`と`catch`については、[例外処理][]で説明します。

---

再帰関数は、必ずしもループよりも非効率的な代替手段というわけではありません。幾つかの問題では、ループよりも再帰関数を使った方がはるかに解きやすいものがあります。よくある例として、何本もの「枝」があり、各々の枝がさらに幾つもの枝を生やしているような構造を探索・処理する問題が挙げられます。

次のパズルを考えてまましょう。まず1から始めて、毎回前の数に5を足すか3を掛けるかして、無限に数を生成してゆく様を想像してみてください。そしてある数に対して、どのような順序で処理を行ったらその数に行き着いたかを見つけ出すための関数を作って下さい。例えば13は、まず1に3を掛けてそれから5を2回足した数字です。一方15には、どう計算してもたどり着くことはできません。

	findSequence = (goal) ->
	  find = (start, history) ->
	    if start == goal
	      history
	    else if start > goal
	      null
	    else
	      find(start + 5, '(' + history + ' + 5)') ? find(start * 3, '(' + history + ' * 3)')
	  find 1, '1'
	show findSequence 24


page 58
---


気をつけて欲しいのは、見つかった解は必ずしも最短の計算過程による結果ではない、ということです。この関数は、最初に見つかった計算過程を返すだけです。

内部の`find`関数は、現在の数に5が足されるのか、あるいは3が掛けられるかを求めるために、自分自身を2種類の方法で再帰呼び出ししてゆきます。関数は目的の数に到達すると、文字列`history`を返します。この変数には、関数がその数にたどりつくまでに実行した演算の履歴が収められています。またこの関数は、現在の数値と目標値を比較しています。現在値が`goal`より大きければ目標値に辿り着くことは不可能であり、その枝の探索を打ち切ることになります。

ここにある存在演算子「`?`」は、「`start`に5を足した結果発見した解法を返す。もしそれが失敗したら、`start`に3を掛けた結果発見した解法を返す」という意味で使われています。

---

通常関数を定義するときは、後で参照して呼び出せるように名前をつけてやります。ただ関数名は必須ではなく、名前を付けない方が良いケースもあります。そんな時は代わりに匿名関数を使いましょう。

例として、先ほど見た`makeAddFunction`関数を少し変えてみます。

	makeAddFunction = (amount) ->
	  (number) -> number + amount

	show makeAddFunction(11) 3

最初のバージョンの`makeAddFunction`にあった`add`は一度しか参照されなかったため、名前は全く役に立っていません。そのため、関数値を直接返したほうが理に適っているでしょう。

## 練習問題9

数値型の引数を一つ取り、数値比較テスト関数を返す関数`greaterThan`を作って下さい。戻り値である関数も一つの数値型を引数に取り、次のように真偽型を返します。すなわち、与えられた数値がテスト関数を作った時の数値より大きかったら`true`を返し、そうではない場合は`false`を返します。


page 59
---


### 解答

	greaterThan = (x) ->
	  (y) -> y > x

	greaterThanTen = greaterThan 10
	show greaterThanTen 9

次の命令文を試してみてください。

	yell 'こんにちは', 'こんばんは', '元気？'

本章の最初のほうで定義された関数`yell`は、引数を一つしか取ることができません。このように呼び出した場合、コンピュータは何一つ文句を言わず、他の引数を無視するだけです。

	yell()

当然ながら、少ない引数で関数を実行することもできます。引数を指定しなかった場合、関数内部での引数の値は`undefined`になります。

次章では、関数本体が複数の引数をリストとしてひとかたまりに受け取る方法を紹介します。これは、関数に対して任意の数の引数を渡すことができるという便利な機能です。

この機能を利用すれば`console.log`を次のように呼び出すことができます。

	console.log 'R', 2, 'D', 2

もちろんデメリットとしては、関数が決まった数の引数を取るにもかかわらず、間違った数の引数を渡してしまい、しかもそれに気付かないというケースがあり得ます。

---
---

## 翻訳者
* Takaichi Kubo
* Takashi Tsuda
* Takahiro Yoshida
* Yayoi Kinosita
* Tsutomu Kawamura


## 不明な点
1. 予約語と変数の色の使い分け(原文では前者が緑斜体monospace、後者が青色monospace)。さらにコメント部分(灰色monospace)
1. 53行目、他多数: 脚注
1. 135, 153行目: べき乗、分数表記はどう書く？
1. 166行目: 「`223`ページ」出版時にページ数の調整
1. 311行目: 原文`variable`は、`varWhich`の間違い？

## 外部リンク
* [関数プログラミング]
* [二分ヒープ]
* [モジュラー性]
* [検索]
* [例外処理]

## 画像
* [FIG52]
[FIG52](../img/environments.png "figure img/environments.png")
---
