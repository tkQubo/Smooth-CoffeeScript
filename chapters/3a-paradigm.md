## page 97

# プログラムの組み立て方

## page 98

# 関数型プログラミング

コードの量が増えるにつれ、プログラムはより複雑に、分かりにくくなってゆきます。いくら賢いと自惚れていても、私たちは所詮、人間というちっぽけな存在に過ぎません。些細な問題にも簡単に躓き、事態はより混沌としてゆく一方でしょう。物事に対して十分な理解無く取り組むのは、映画でよくあるように、時限爆弾のコードを当てずっぽうに切断するのと大差ありません。映画の主人公であればクールに爆弾を解除できるかもしれませんが、物事はそううまくは運びません。下手したら大爆発を引き起こすケースもあります。

もちろん、プログラムを破壊して大爆発が起こるようなことはまずありません。しかし誰かが考えなしにプログラムをいじって、エラーだらけのハチャメチャな状態にしてしまった場合、それをまともな状態に復旧させるのは至難の業です。最悪、最初から作り直したほうがまだましかも知れません。

それゆえプログラマは、コードを可能な限りシンプルに保つ方法を常に模索しているのです。重要なプラクティスとしては、より抽象的なコーディングを目指し、実践することです。プログラムを書く際、その都度些細なディテールにとらわれ、本質から逸脱してしまうことはよくあります。小さな問題にぶつかり、それを処理した後に別の小さな問題にぶつかる―これの繰り返しです。おかげで、コードは次のような年寄りの長話みたいになってしまうのです。

> いいこと？エンドウ豆のスープを作るときは、まずスプリットピーを用意しなさい。乾燥したエンドウ豆のことよ。それを必ず一晩は水に浸しておくこと。じゃないと調理するのに何時間かかるか分かったものじゃないわ。そうそう！昔、おっちょこちょいの息子がエンドウ豆スープを作ろうとしたことがあってね、あの子ったらエンドウ豆を水に浸しておかなかったの、信じられる？私たちみんな、歯が折れちゃうかと思ったくらいよ。あら、こんな話をしてる場合じゃなかったわね。それでエンドウ豆を水に浸すんだけど、一人前でカップ一杯分必要よ。水に漬けるとエンドウ豆は少し膨れるから分量には気を付けなさい。うっかりしてると、容器からこぼれちゃうわよ。たっぷりの水で浸しておきなさい。どれだけのエンドウ豆を浸すかって言うと、さっき言ったとおり、カップ一杯分よ。乾燥状態のエンドウ豆をね。それで水に浸してから、カップ一杯分の分量につき4カップの水で調理するの。 

## page 99

> ２時間くらいコトコト煮込こみなさい。フタをしてそのまま放っておくだけ。その後角切りにした玉ねぎ、スライスしたセロリを入れるの。他にもニンジンを1、2本、それにハムとかを入れるのもいいわね。さああと何分か煮込んだら、もう出来上がりよ！

さて、このレシピを次のように言い換えてみましょう。

> 一人前：乾燥スプリットピー1カップ、玉ねぎのみじん切り（1/2個）、ニンジン（1/2本）、セロリのスライス、お好みでハムなど。
一晩水に浸したエンドウ豆を、一人前につき4カップの水で2時間煮込みます。それから野菜やハムを加え、さらに10分間調理します。

後者のレシピはより簡潔になっていますが、もし作り手がエンドウ豆の浸し方を知らない場合、浸しておく水が少なすぎて失敗するのは目に見えています。しかしエンドウ豆の浸し方は別に調べれば済むことですし、おかげでレシピがコンパクトに収まっているのです。聞き手がある予備知識を共有している場合、話し手はより大きな文脈で会話ができ、物事をより簡潔にかつ明確に表現することができます。これはまさに、抽象化のプロセスとも言えるのではないでしょうか。

しかしこのやや強引とも言えるレシピのエピソードは、プログラミングと何の関係があるのでしょう？すでにお分かりのことと思いますが、レシピとはプログラムのことです。もっと言えば、料理が前提とする基礎知識は、プログラマが利用できる関数やその他の構成要素に相当します。本書の導入部分で紹介した`while`などを使えばループ処理が簡単になります。また[データ構造][]では簡単な関数を用いて、他の関数をコンパクトに、より分かりやすいものにしました。これらの機能は、言語そのものが提供しているものもあれば、プログラマ自身が実装することもあります。プログラムから非本質的な細部を削り、扱いやすくするために利用するのです。

---

本章のテーマである関数型プログラミングは、関数を効果的に組み合わせることにより抽象化を実現します。プログラマは、幾つかの基本的な関数、さらにはそれらを利用するためのノウハウを身に付けていれば、何の知識もない状態から始める場合に比べて、圧倒的に効率的なプログラミングが可能になります。しかし残念なことに、標準的なCoffeeScript環境には、必須とも言える関数はほとんど実装されていません。それらは自分たちで用意するか、あるいはもう少しまともな選択肢として、誰か他の開発者のコードを利用することをお勧めします。詳しくは[モジュラー性][]をご参照下さい。

## page 100

この章では便利な関数群を作ってゆき、それらがどのように作用してどのように問題を解決するのかを通して、その利用法を理解してゆきます。本章以降は、CoffeeScriptに付属のUnderscoreライブラリに収められている、より多くの関数群を扱ってゆきます。

抽象化の方法としては、他にも有力な選択肢が挙げられます。最も特筆すべきはオブジェクト指向プログラミングです。詳しくは[オブジェクト指向][]をご覧ください。

---

プログラミングで、配列内の各要素に対して基本的な操作を行う場合があります。多くのプログラミング言語は、Ｃ言語のやり方を真似てこれを実現しています。

	size_t i;
	size_t N = sizeof(thing) / sizeof(thing[0]);
	for (i = 0; i < N; ++i) {
		do_something(thing[i]);
	}

まともな感覚を持っている者であれば、これは非常に醜い代物に見えることでしょう。C++やJavaScriptなどのCから派生した言語においては、もう少しましな書き方になります。他のプログラミング言語では、更に異なった手法を採用しています[^17]。例えばCoffeeScriptでは、このくらい分かりやすくなっています。

	for i in [0...thing.length] then doSomething thing[i]
	# あるいは
	for element in thing then doSomething element

しかし、この表現にしても面倒な繰り返し表記は残っています。このプロセスを抽象化することは可能でしょうか？

ここで厄介な問題が一つあります。それは、ほとんどの関数が「簡単な引数を取り、それらを組み合わせて、何かを返す」というシンプルな形を取っているのに対して、今述べたようなループには「実行すべきコードそのもの」が要素として含まれているということです。配列を受け取って、各要素を出力する関数を書くのは簡単です。

	printArray = (array) ->
		for element in array
			show element
		return

[^17]: Mathematicaでは関数はリスタブルとして定義でき、繰り返し処理の記述を省ことができます。
	f[x_] := If[x > 0, Sqrt[x], Sqrt[-x]]; SetAttributes[f, Listable];
	f[{3, 0, -2}] ⇒ {√3, 0, √2}

## page 101

しかしもし出力以外で何か処理をしたくなった場合はどうすればいいでしょうか？実は「何か処理を行う」ことは関数として表現可能であり、かつ関数も変数値として扱えるため、その「何か処理を行う」関数自身を別の関数に引数として渡すことができるのです。

	forEach = (array, action) ->
		for element in array
			action element
		#return
	forEach ['Wampeter', 'Foma', 'Granfalloon'], show

CoffeeScriptでは、ほとんどの命令文の正体は「値を返す表現式」ですが、それは`for`構文にも当てはまります。最後に`return`文があれば、`forEach`は`undefined`を返します。ここでは`forEach`はその値を返しています。何故そうするのかは、`map`関数を使う時に明らかになります。
匿名関数を利用すれば、forループのようなものは次のように書くことができます。

	sum = (numbers) ->
		total = 0
		forEach numbers, (number) -> total += number
		total
	show sum [1, 10, 100]

スコープ化のルールにより、変数`total`は匿名関数内でアクセス可能です。しかしこのバージョンは`for`ループと比べてもコードの長さはほとんど変わりません。

配列内の各要素が変数`number`に格納されるため、`numbers[i]`などのような表記は不要です。また何らかの表現式の評価結果として配列が生成される場合も、いちいちそれを別の変数に代入しなくても、`forEach`に直接渡すことができます。

[データ構造][]のcat-codeには、このようなコードがありました。

	paragraphs = email.split '\n'
	for paragraph in paragraphs
		handleParagraph paragraph

これを次ように書き換えることができます。

	forEach email.split('\n'), handleParagraph

一般的に言えば、抽象的な、あるいは「高次な」構造を利用すれば、より密な情報量でノイズの少ないコードを書くことができます。関数`sum`のコードは、「配列numbers内の個々の要素をnumberとして取り出し、その値をtotalに加えてゆく」と読むことができます。元々のコードの

## page 102

「ある変数があります。この変数を、0から配列numbersの長さまで数えてゆくわけですが、カウントアップの際に配列内の対応する位置にある要素を参照して、その値をtotalに加えてゆく」と比べてみてください。

---

`forEach`の真髄は、「配列を走査する」というアルゴリズムを抽象化することにあります。「配列内の各要素に対して何を行うか」という肝心のアルゴリズムの「中身」は、`forEach`関数に引数として渡される関数が実現してくれます。

他の関数上で作用する関数のことを、高階関数と呼びます。関数が関数を処理するという視点は、物事の処理に関して全く新しい地平を切り開いてくれます。[関数][]で紹介されていた`makeAddFunction`も、高階関数の一つです。この場合は関数を引数に取る代わりに、関数を戻り値として返します。

高階関数を使えば、通常の関数では実現の難しかった多くのアルゴリズムを一般化することが可能です。これらの関数を身につけ自在に操ることができれば、より分かりやすいコーディングを行うことができるでしょう。ごちゃごちゃした変数やループを使うのではなく、問題のアルゴリズムを幾つかの本質的なアルゴリズムの組み合わせに分割し、各々を必要に応じて呼び出すことによって、同じコードを何度も打ち込む手間が省けます。

「どのように実行するか」ではなく「何を実行するか」を書くことは、作業をより高度な抽象度にまで高めてくれます。それはより短く明確で、かつ快適なコーディングを保証します。

---

また別の使い方として、高階関数は、引数として与えられた関数をカスタマイズすることもできます。

	negate = (func) ->
		(x) -> not func x
	isNotNaN = negate isNaN
	show isNotNaN NaN

`negate`が返す関数は、元々の関数`func`に引数を与えて、その結果に対して否定演算を行います。ここで、否定演算を適用したい関数が、二つ以上の引数をとる場合はどうしたら良いでしょうか？ 

## page 103

関数に渡した引数は`arguments`という配列から取得することはできますが、引数が幾つ必要であるか分からない場合、どのようにして関数を呼び出せばよいでしょうか？

関数オブジェクト[^18]は`apply`と呼ばれる関数を持っており、これは次のような場合に用います。まず`apply`は二つの引数を取ります。1番目の引数に関しては、[オブジェクト指向][]の説明をご覧下さい。ここではシンプルに`null`を使います。2番目の引数には、対象の関数が必要とする引数を配列として入れます。ここで暗黙の変数である`arguments`を使うこともできますし、スプラット（`...`）を使うこともできます。

	show Math.min.apply null, [5, 6]
	negate = (func) ->
		-> not func.apply null, arguments
	negate = (func) ->
		(args...) -> not func args...

---

配列に関して、基本的なアルゴリズムをもう少し紹介したいと思います。実は関数`sum`は、一般的に`reduce`や`foldL`と呼ばれるものの一種に過ぎません。

	reduce = (array, combine, base) ->
		forEach array, (element) ->
			base = combine base, element
		base

	add = (a, b) -> a + b
	sum = (numbers) -> reduce numbers, add, 0
	show sum [1, 10, 100]

`reduce`は、ベースとなる値を用意し、それに対して配列内の個々の要素を結合することによって、配列を一つの値へと集約します。これは`sum`の働きと全く同じです。従って`reduce…`を用いて`sum`をコンパクトに改良することができます。ただCoffeeScriptでは加算は関数ではなく演算子ですから、まず加算を関数で定義する必要があります。

[^18]: 残念ながら、少なくとも古いバージョンのInternet Explorerにおいては、`alert`などの多くのビルトイン関数は、実際には関数としては実装されていません。`typeof`演算子を使った場合、これらの「関数」は`'object'`を返します。またこれらは`apply`を持ちません。一方、自分で作成した関数は問題ありません。それらは本当の意味での関数となります。

## page 104

## 練習問題21

数値型の配列を引数に取り、その中に出現する0の数を数える、`countZeros`関数を作ってください。ただし、その際`reduce`を使ってください。

そして、配列とテスト関数を引数に取り、配列の要素のうちテスト関数が`true`を返すものの数を数える高階関数`count`を作ってください。また、この関数を用いて`countZeros`を再実装してください。

### 解答

	countZeroes = (array) ->
		counter = (total, element) ->
			total++ if element is 0
			total
		reduce array, counter, 0

	bits = [1, 0, 1, 0, 0, 1, 1, 1, 0]
	show countZeroes bits

こちらは`count`を使った解になります。等価性の評価関数を返す関数を利用することで、最終的な`countZeroes`をさらに短いものにしています。

	count = (test, array) ->
		reduce array, ((total, element) ->
			total + if test element then 1 else 0), 0

	equals = (x) ->
		(element) -> x == element

	countZeroes = (array) ->
		count equals(0), array

	show countZeroes bits

配列を扱う際に様々な用途に役立つ「基本的アルゴリズム」をもう一つ紹介しましょう。それは`map`です。

## page 105

`map`は`forEach`と同様に、配列内の各要素に対して関数を適用します。しかし関数の戻り値を破棄するのではなく、その個々の戻り値から新たな配列を作り出すのです。

	map = (array, func) ->
		result = []
		forEach array, (element) ->
			result.push func element
		result

	show map [0.01, 2, 9.89, Math.PI], Math.round

ちなみに`function`は予約語ですので、変数名としては使えません。従って2番目の引数では`func`としています。さらに続けて、

	# forEach自体が戻り値を返しているので、resultを省略します
	map = (array, func) ->
		forEach array, (element) ->
			func element

	# 引数のfuncを省略します
	map = (array, func) ->
		forEach array, func

	# forEachの引数を省略します
	map = forEach

この一連の例から分かるとおり、複数の関数や表現式をうまく使うことで、一つの関数をコンパクトにまとめることができます。`forEach`のパフォーマンスが気になるようであれば、定義の最後に`return`を加えてみましょう。そうすれば`for`内包表記の計算結果は保存されません。ただしその場合、`map`の実装を別に行わなければいけません。

---

むかしむかし、トランシルバニアの山林の奥深く、一人の世捨て人が住んでいました。山中をそぞろに歩き、木々に語りかけ、鳥たちとともに笑いあう、そんな毎日を送っていました。ある日のことでした。大雨のせいで小さな掘っ立て小屋から出ることができず、おまけにビュービュー吹きすさぶ風の音のせいで、彼は自分がひどくちっぽけな存在になってしまったような気になってきました。彼はとにかく何か物を書きたい、取り留めない事を紙に綴ってゆけば、こんな惨めな思いから抜け出せるのでは、と思いました。

## page 106

詩を書いたり、小説や哲学にも手を出しましたがどれもうまくいきません。世捨て人はついに、一冊の技術書を書くことを決意しました。彼は若い頃にプログラミングの経験があったのです。その時のことをうまく本にできれば、きっと人から評価され、名声を得られることでしょう。

そうして彼は書き始めました。最初は木の皮に書いていたのですが、これはあまり現実的ではないことに気づいたようです。そこから彼は近くの村に下り、一台のノートパソコンを買いました。何章か書き進めた後に、彼は本をHTMLフォーマットにして、ウェブサイトに公開したいと考えるようになりました…。

![figure img/html.png](../img/html.png?raw=true)

突然ですが、HTMLはご存知でしょうか？HTMLとはウェブページにマークアップを記述する言語のことです。この本にもHTMLは使われていますし、HTMLがどのようなものなのかは、知っておいて損は無いはずです。優秀な生徒であれば、すぐにでもインターネットでHTMLについて調べ、理解してくれることでしょう。しかしながら大半の優秀ではない学生たちのために、さしあたってHTMLについて簡単な説明をしてゆきます。

HTMLとは、HyperText Mark-up Language(ハイパーテキストマークアップランゲージ)の略です。HTMLドキュメントは、テキストで書かれています。どのテキストが見出しでどのテキストが紫色かなどの情報―すなわちテキストの構造―を記述するため、幾つかの文字は特別な意味を持っています。CoffeeScriptの文字列におけるバックスラッシュのようなものです。ここでは「>」(半角大なり)と「<」(半角小なり)の記号が、「タグ」を形成します。タグは、ドキュメント内のテキストに対して追加の情報を賦与します。

## page 107

タグは、ページに表示する画像の位置を指定する時のようにそれ自体完結した要素として扱えますし、あるいは段落の始まりと終わりを示す時のように、テキストや他のタグを内部に含むこともできます。

幾つかのタグは必須タグです。HTMLドキュメントは、`html`タグの中に書かなければいけません。HTMLのバージョンは、最初の一行目にドキュメントタイプ、すなわち`DOCTYPE`に指定します。ブラウザはこれを見て、正しくドキュメントを解析しレンダリングを行うわけです。以下はHTML5ドキュメントの例になります。

	<!DOCTYPE HTML>
	<html>
		<head>
			<meta charset="utf-8"/>
			<title>引用</title>
		</head>
		<body>
			<h1>引用</h1>
			<blockquote>
				<p>
					我々がプログラミングを行う時に用いる言語と、
					我々が考えうる問題及びその解法との間は、非常に密接な関係がある。
					この理由によって、プログラマからエラーを取り除くために言語機能に
					制限を設けることは、ひいき目に見ても危険であると言える。
				</p>
				<p>-- ビャーネ・ストロヴストルップ</p>
			</blockquote>
			<p>
				ストロヴストルップ氏はC++プログラミング言語の開発者はでありますが、
				それにもかかわらず深い洞察力を持っています。
			</p>
			<p>
				そしてこちらがダチョウの写真になります
				（訳注：ダチョウ＝「現実逃避者」の暗喩？）
			</p>
			<img src="../img/ostrich.jpg"/>
		</body>
	</html>

テキストや他のタグを内部に含んだタグは、<タグ名>で始まり、</タグ名>で終わります。`html`要素は、必ず二つの子要素を持ちます。それは`head`と`body`です。`head`にはドキュメントの情報が含まれており、`body`には実際のドキュメントが含まれています。
タグ名の多くは、やや分かりにくい省略形となっています。`h1`は「見出し１(=heading 1)」を意味します。これは一番大きな見出しです。見出しは他にも`h2`から`h6`まで揃っており、数値が大きいほど小さな見出しになります。`p`は「段落(=paragraph)」を意味し、`img`は「画像(=image)」を意味します。`img`要素は内部にテキストや他のタグを含むことはありませんが、`src="…/img/ostrich.png"`のような追加情報を持っています。これは「属性」と呼びます。ここには、表示すべき画像ファイルの情報が書かれています。
「<」と「>」はHTMLドキュメントにおいて特別な意味を持っているため、ドキュメント内のテキストに直接書くことはできません。 

## page 108

例えばドキュメント内で「5 < 10」と書きたい場合、「5 `&lt;` 10」と書く必要があります。ここでltは「小なり(=less than)」を意味します。そして「`&gt;`」は「>(=greater than)」を意味します。ここでアンド記号（&）に特別な意味が与えられているため、単純な文字としての「&」は、「`&amp;`」と書きます。

さて、今まで述べてきたことは、必要最低限のHTML入門編でしかありません。しかしHTMLドキュメントを扱う本章および次章以降を読み進めてゆく上では、これで十分でしょう。

---

preludeには、HTMLドキュメントを表示するための関数`viewURL`が用意されています。上に挙げたサンプルドキュメントは、「`06-Quote.html`」に保存されていますので、以下のコードを実行してその内容を表示させてみて下さい。

	viewURL '06-Quote.html'

また、プログラムで小さなサーバーを立てたり、インタラクティブなCoffeeScript環境（REPL）を使うことも可能です。それによって文字列あるいはファイルからウェブページを表示させることができます。作成したウェブページを、例えば`stroustrupQuote`といった変数に格納した場合、次のようにしてサーバーを立ち上げることができます。

	viewServer stroustrupQuote

あるいは、ファイル名を引数として与えても構いません。サーバーを閉じる時は、`stopServer()`とタイプするか、`CTRL＋C`を押してください。

---

さて物語を再開しましょう。我らが世捨て人は、自分の本をHTMLフォーマットにしたいと考えています。彼はまず、全てのタグを原稿に直接書いていました。しかし「<」や「>」をいちいちタイピングしてゆくのは、大変な骨折りです。おまけに彼は、アンド記号の必要な箇所に`&amp;`と書くことをしょっちゅう忘れてしまいます。どうしたらいいものか、彼は頭を抱えて悩み始めました。そこで、次に彼はMicrosoft Wordを使い、原稿をHTMLとして保存してみました。しかし出力されたHTMLは、本来あるべきファイルよりも15倍ほど大きく、複雑なものになってしまいます。さらに悪いことに、Microsoft Wordそのものが使い辛く別な頭痛の種となってしまいます。

最終的に思いついたソリューションは次の通りです。まず本を飾り気の無い単純なテキストとして書き始めます。しかしそこに、段落の分け方と見出しの付け方に関してシンプルな規則を適用することにしたのです。次に彼は、このテキストを正確にHTMLに変換してくれるプログラムを書きました。

規則は、次の通りです。

## page 109

1. 各段落は、空行で分けられている
2. 「%」記号で始まる段落は、見出しである。「%」記号が多ければ多いほど、見出しは小さくなる。
3. 段落中で、アスタリスクに囲まれたテキストは強調表示される
4. 脚注は、大括弧の間に書く

---

6ヶ月にもわたる艱難辛苦に満ちた執筆作業にもかかわらず、世捨て人は、ほんのわずかの段落しか完成させることができていません。掘っ立て小屋は雷に打たれ、彼は大いなる野望を抱えたまま、帰らぬ人となってしまいました。こうして黒焦げになったノートパソコンから、私は以下のファイルを復旧させることに成功したのです…。

> % プログラミングの本

> %%　陰と陽

>  マシンの奥深くで、プログラムが蠢いている。それはいとも容易く拡大と縮小を繰り広げる。偉大なる調和の元に、電子は離れそして再び集うのだ。モニター上のイメージは、水上のさざなみに如かず。真理は我々の見えないところに存在する。

> 天はPCに、CPUとメモリを与えた。ここからプログラムの陰陽が浮き彫りにされる。

> まずCPUとは、能動的な存在である。これはコントロールと呼ばれる。一方でメモリは、受動的な存在である。これはデータと呼ばれる。

> データは単純なビットからできているが、複雑な情報の担い手となる。コントロールはシンプルな命令から成り立っているが、それでも難しいタスクを実行することができる。矮小でちっぽけなものから、偉大で複雑なものが生まれるのだ。

> プログラムのソースはデータである。コントロールはそこから生じる。そしてコントロールは新しいデータを生成する。一方がもう一方から生まれ、もう一方は一方の存在無しには意味を持たない。これこそがデータとコントロールの調和的な循環である。

> データもコントロールも、それ自身は何の構造も持っていない。いにしえのプログラマは、これらの原料を型に流し込むようにプログラムを作り上げていた。 

## page 110

> 時は流れ、無定形のデータはデータ型へと結晶化され、混沌たるコントロールはコントロール構造及び関数へと集約されてゆく。

> %% 対話

> 門人が孔子に、データとコントロールの循環的な性質について問う。孔子これに応えて曰く「コンパイラはどうだい、自分自身をコンパイルしているじゃないか」

> 門人が問いて曰く「いにしえのプログラマは、シンプルなマシンしか使わず、プログラミング言語なんてありませんでした。しかしそれでも美しいプログラムを書くことができたそうです。ならばどうして私たちに複雑なマシンと複雑なプログラミング言語が必要なのでしょうか？」孔子、これに応えて曰く「そうだね。いにしえの建築家たちは棒切れと粘土しか使わなかったが、それでも美しい掘っ立て小屋を作ることができたがね。」

> ある隠者が10年かけてプログラムを書き終えた。自らを誇りて曰く「私のプログラムは、MS DOSの動く286マシンで、天体の動きを計算することができる。」孔子、これに応えて曰く「誰も286マシンなんて持っちゃいないし、MS DOSなんて使っちゃいないよ。」

> 孔子がグローバル変数や怪しげなショートカットだらけの、小さなプログラムを書き上げた。それを見た門人が問いて曰く「先生は使ってはいけない手法について教えて下さいましたよね。それなのに先生のプログラムにはそれらが使われているようです。これはどういうことですか？」孔子、これに応えて曰く「家が燃えていないならば、わざわざ水道ホースを引っ張り出す必要は無いのだよ。」{これは杜撰なプログラミングを勧めるものではない。原則に固執することの危険性を指摘しているのである。}

> %% 叡智

> 門人が、数値に関して愚痴りて曰く「２の平方根を二乗しただけなのに、計算結果が狂っている！」これを聞き孔子、莞爾として笑いて曰く「ここに一枚の紙がある。どうか２の平方根の正確な値を書いてくれないかね。」

> 孔子曰く「木理を切る時は、大変な力が必要だ。小さな問題をプログラムで解く時でも、大変な量のコードが必要なのだよ。」

> 子路と子索が、最近書いたプログラムのサイズで競い合っている。「俺は20万行書いたぞ！」子路曰く「コメント抜きでだ！」「ほう」子索曰く「私のは\*100万\*行を超えたがね。」 孔子曰く「私のベストプログラムは500行だよ。」これを聞き、子路と子索は啓かれる。

## page 111

> 門人、眉をしかめてPCの前に座ったまま、数刻微動だにせず。難しい問題を解くために美しいコードを書こうとするも、どうしてもそれを見出せずにいた。孔子が彼の後頭部をたたき、叱り付ける「\*とっととコーディングしたまえ！\*」門人は汚いコードを書き始める。それを書き上げた時、彼は忽然として美しいコードに思い至った。

> %% 前進

> プログラミング初心者は、まるでアリが塚を築くがごとく、大きな構造を考えずに一気にプログラムを書き始める。そのコードはまるでサラサラの砂のようだ。小さなものならともかく、少し大きなプログラムを組み立てようとすると、たちまち崩れてしまう。{コード内部の一貫性の無さや、重複コードによって生じる危険性を指している。}

> プログラマはこの問題に直面し、構造について多大な時間を費やして考えるようになる。やがてプログラムは、岩彫刻のようにがっしりしたものになってゆく。堅牢なプログラムはしかし、ひとたび変更の必要に迫られたとき、暴力に訴えなければそれを変えることはできない。 {構造そのものが、プログラムの発展を妨げてしまうという傾向を示している。}

> 真のプログラマは、構造を用いることと単純なコーディングを行うこととのバランス感覚を心得ている。そのプログラムは粘土のように、堅牢かつ柔軟であるのである。

> %% 言語

> プログラミング言語は、シンタクスとセマンティクスを備えたものとして作られた。シンタクスはプログラムの形式を、セマンティクスはその機能をつかさどる。シンタクスが美しくセマンティクスが明確であるならば、プログラムは堂々たる樹木の容をなす。シンタクスが拙く、セマンティクスが混沌としていると、プログラムは茨の茂みとなる。

> 子索はJavaと呼ばれる言語でプログラムを書くよう命じられた。Javaは、非常に原始的な関数の使い方を要請する言語である。彼は毎朝PCの前に座っては、文句を言い始める。こいつは全てを滅茶苦茶にしてしまうどうしようもない言語であると、彼は一日中口汚く罵っていた。孔子、これをしばらく聞き、そして彼に近づいて曰く「どんな言語にもやり方というものがあるのだよ。その形式に従いなさい。決して別の言語を扱うかのごとくコーディングをしてはいけないよ。」

## page 112

--

われらが世捨て人の想いを無駄にしないためにも、ぜひHTML生成プログラムを作ってみましょう。HTMLの生成に関して、以下のようなプロセスが考えられます。

1. ファイルを、空の行で区切って幾つかの段落に分ける
2. ヘッダ行から%記号を取り除き、ヘッダとしてマーキングする
3. 段落内のテキストを処理する。通常部分、強調部分、そして脚注部分へと分割する。
4. 全ての脚注をドキュメントの一番下に移動し、脚注のあった箇所に数字[^19]を入れておく。
5. 各分割部分を正しくHTMLタグでマークアップする
6. 全体を一つのHTMLドキュメントとしてまとめる

ただこの手法では、強調されたテキスト内に脚注を入れることはできませんし、逆もまた無理です。やや貧弱な仕様と思われるでしょうが、代わりにサンプルコードをシンプルにできます。この章を終えて物足りないと感じるようであれば、ネスト可能なマークアップをサポートするようにプログラムを改良してみてはいかがでしょうか。

原文は「`06-RecluseFile.text`」に収められています。preludeにある`readTextFile`関数を使って、中身を文字列として取り出してみましょう。

	recluseFile = readTextFile '06-RecluseFile.text'

---

アルゴリズムのステップ１は至極簡単です。空の行は、2つの改行が連続して続いた場合に発生します。ところで、以前[データ構造][]で`split`を使ったのを覚えているでしょうか。この関数を使えばステップ１は簡単に実現できます。

	paragraphs = recluseFile.split "\n\n"
	show "Found #{paragraphs.length} paragraphs."


[^19]: こんな感じです

## page 113

## 練習問題22

段落文字列を引数として受け取り、その段落がヘッダかどうかをチェックする関数、`processParagraph`を作ってみてください。ヘッダの場合、%記号を切り分け、その数を数えましょう。それから段落内のテキストを含んだ`content`というプロパティ、及び段落をラップするタグを含んだ`type`というプロパティ、この2つのプロパティを持ったオブジェクトを返します。ここで`type`には、通常の段落の場合は「`p`」が入り、%記号が1つの場合は「`h1`」が入ります。%記号が`X`個あるのに対して、`type`の値は「`hX`」となります。

### 解答

	processParagraph = (paragraph) ->
		header = 0
		while paragraph[0] == '%'
			paragraph = paragraph.slice 1
			header++
		type: if header == 0 then 'p' else 'h' + header,
		content: paragraph

	show processParagraph paragraphs[0]

ここで、先ほど紹介した`map`を試すときが来ました。

	paragraphs = map recluseFile.split('\n\n'),
					processParagraph
	show paragraphs[0..2]

さあ、これで綺麗に分類された段落オブジェクトのできあがりです！この調子で進んでゆきましょう。アルゴリズムその3を忘れていますね。

	段落内のテキストを処理する。通常部分、強調部分、そして脚注部分へと分割する

この処理は、次のように分解可能です。

1. 段落がアスタリスクで始まっている場合、強調部分を取り出し、保存します。
2. 段落が開き中括弧で始まっている場合、脚注を取り出し、保存します。
3. それ以外の場合、強調部分もしくは脚注に出会うまで、あるいは文字列の最後までを抜き出し、通常テキストとして保存します。
4. 段落内に文字列が残っている限り、1から処理を繰り返します。

## page 114

## 練習問題23

段落文字列を受け取り、段落パーツの配列を返す、`splitParagraph`関数を作ってみましょう。パーツを表現するための工夫が必要です。パーツは`type`と`content`というプロパティを持っています。

ここでは関数`indexOf`が役に立つでしょう。この関数は、文字列中から文字あるいは部分文字列を検索し、見つかった場合はその位置を、見つからなかった場合は-1を返します。

アルゴリズムはトリッキーですので、全く正しくないものになるか、あるいはあまりに長すぎるものになってしまうかもしれません。困難に直面したときは、立ち止まってちょっとだけ考えてみてください。アルゴリズムを補助する小さな処理を行ってくれる、内部関数を書いてみてみましょう。

### 解答

一つの例として参考にしてみてください。

	splitParagraph = (text) ->
		# 文字の位置、あるいはテキストの最後を返します
		indexOrEnd = (character) ->
			index = text.indexOf character
			if index == -1 then text.length else index

		# 次の特殊文字あるいはテキストの最後までの文字列を返し、それを除きます
		takeNormal = ->
			end = reduce map(['*', '{'], indexOrEnd),
						Math.min, text.length
			part = text.slice 0, end
			text = text.slice end
			part

		# 引数の文字までを返し、取り除きます
		takeUpTo = (character) ->
			end = text.indexOf character, 1
			if end == -1
				throw new Error 'Missing closing ' +
								'"' + character + '"'
			part = text.slice 1, end
			text = text.slice end + 1
			part

		fragments = []

		while text != ''
			if text[0] == '*'
				fragments.push
					type: 'emphasised',
					content: takeUpTo '*'
			else if text[0] == '{'
				fragments.push
					type: 'footnote',
					content: takeUpTo '}'
			else
				fragments.push
					type: 'normal',
					content: takeNormal()
		fragments

## page 115

`takeNormal`内で、`map`と`reduce`が頻繁に使われていることに注目してください。この章は関数プログラミングの章であり、従って関数的なプログラミングを目指しましょう！これがどのように動くか分かりますか？`map`は与えられた文字が見つかった位置、あるいは見つからなかった場合は文字列の最終位置、これらの配列を返します。そして`reduce`はそれらの中での最小値を取ります。この値が、文字列内で次に処理を開始する地点になります。`map`と`reduce`を使わなかった場合、関数は例えば次のようになります。

	takeNormalAlternative = ->
		nextAsterisk = text.indexOf '*'
		nextBrace = text.indexOf '{'
		end = text.length
		if nextAsterisk != -1

## page 116

			end = nextAsterisk
		if nextBrace != -1 and nextBrace < end
			end = nextBrace
		part = text.slice 0, end
		text = text.slice end
		part

このやり方は大変ひどいですね。概して、複数の要素を処理する必要がある場面では、たとえ要素数が2つだけだったとしても、配列操作として扱うほうが、それぞれの値を個別のif節で扱うよりも良いコードになります。(幸いなことに[正規表現][]では、文字列中に最初に出てくる「この文字か、あの文字」を簡単に探す方法が説明しています)

もし上に挙げた解答以外の方法でパーツを保存する`splitParagraph`を書いたのであれば、修正することをお勧めします。なぜなら、本章の残りで出てくる関数は、パーツ配列が`type`と`content`の2つのプロパティを持ったオブジェクトの配列であることを前提としているからです。

ここから`processParagraph`を連携させて、段落内のテキストを分割します。私の場合、このように修正しました。

	processParagraph = (paragraph) ->
		header = 0
		while paragraph[0] == '%'
			paragraph = paragraph.slice 1
			header++
		type: if header == 0 then 'p' else 'h' + header,
		content: splitParagraph paragraph
	# 追加テスト
	recluseFile = readTextFile '06-RecluseFile.text'
	paragraphs = map recluseFile.split('\n\n'),
					processParagraph
	show paragraphs, 3

段落の配列に対してmap処理を行い、段落オブジェクトの配列を取得します。このオブジェクトは、内部にパーツオブジェクトの配列を持っています。次は脚注を取り出し、元の場所に参照点を追加しましょう。

大体次のようになります。

## page 117

	extractFootnotes = (paragraphs) ->
		footnotes = []
		currentNote = 0
		replaceFootnote = (fragment) ->
			if fragment.type == 'footnote'
				++currentNote
				footnotes.push fragment
				fragment.number = currentNote
				type: 'reference', number: currentNote
			else
				fragment

		forEach paragraphs, (paragraph) ->
			paragraph.content = map paragraph.content,
									replaceFootnote
		footnotes

全てのパーツに対して`replaceFootnote`を適用します。移動すべきではないパーツの場合は、関数はそのままその値を返します。脚注だった場合は、その脚注を配列に保存し、脚注への参照を返します。この過程で、全ての脚注とその参照の両方に数字が割り振られることになります。

---

これで、ファイルから必要な情報を抽出する道具立てがそろいました。残った作業は、正しいHTMLを生成することだけです。多くの人々は、HTMLを作るには文字列の連結が最良であると考えています。例えば、囲碁をプレイできるサイトへのリンクが必要な場合は、このようにすることでしょう。

	url = "http://www.gokgs.com/"
	text = "Play Go!"
	linkText = "<a href=\"#{url}\">#{text}</a>"
	show linkText

(ここで`a`は、HTMLドキュメント内にリンクを作るためのタグを意味します)しかしこれはやり方が拙いだけでなく、`text`文字列が山括弧やアンド記号を含んでいた場合、このタグは間違っていることになります。そうなるとウェブサイトの挙動がおかしくなるでしょうし、「このサイトの作り手はとんでもない素人だ」と判断されてしまうでしょう。そんなことは避けなければいけません。ここでシンプルなHTML生成関数をいくつか書いてみることにします。簡単な作業ですので、早速やってみましょう。

---

## page 118

HTML生成を成功させるための秘訣は、HTMLをフラットなテキストとしてではなく、データ構造として扱うことです。CoffeeScriptのオブジェクトを使うと、簡単にモデリングを行うことができます。

	linkObject =
		name: 'a'
		attributes:
			href: 'http://www.gokgs.com/'
		content:['囲碁をプレイ！']

各々のHTML要素は、タグ名に相当する`name`プロパティを持っています。タグが属性を持つ場合、HTML要素は`attributes`プロパティを持ち、そこには様々な属性が保存されているオブジェクトが入ります。タグに中身がある場合、要素内に含まれる他のHTML要素の配列を収めた`content`プロパティを持つことになります。文字列型は、HTMLドキュメント内のテキストの役割を果たします。従って配列`['囲碁をプレイ！']`は、リンク内にはただ一つの要素、すなわちシンプルなテキストしか含まれていないことを意味します。

これらのオブジェクトを直接タイピングするのは面倒ですし、わざわざそうする必要はありません。ここで手間を省いてくれる関数を作りましょう：

	tag = (name, content, attributes) ->
		name: name
		attributes: attributes
		content: content

ここで、`attributes`や`content`などを適用しない場合、それらに`undefined`をセットするものとしましょう。ですので関数の2つ目と3つ目の引数は、必要なければ空にしておけます。

関数`tag`はまだ初歩の段階です。リンクやシンプルなドキュメントの外部構造など、HTML要素の基本的な型を作るためのショートカットを用意します。

	link = (target, text) ->
		tag "a", [text], href: target

	show link "http://www.gokgs.com/", "囲碁をプレイ！"

	htmlDoc = (title, bodyContent) ->
		tag "html", [tag("head", [tag "title", [title]]),
					tag "body", bodyContent]
	show htmlDoc "引用",
		"ルルイエの館にて 死せるクトゥルフ 夢見るままに 待ちいたり"

## page 119

## 練習問題24

必要であればサンプルのHTMLドキュメントの参考にし、画像ファイルの場所を与えると`img`要素を生成する`image`関数を作ってください。

### 解答

	image = (src) ->
		tag 'img', [], src: src

ドキュメントが完成したら、それを文字列にまで落とし込まなければいけません。これまで作ってきたデータ構造から文字列を組み立てるのは、非常にシンプルなやり方でできます。ここで重要なのは、ドキュメントのテキスト部分の特殊文字を変形処理することです。

	escapeHTML = (text) ->
		replacements = [[/&/g, '&amp;']
						[/"/g, '&quot;']
						[/</g, '&lt;']
						[/>/g, '&gt;']]
		forEach replacements, (replace) ->
			text = text.replace replace[0], replace[1]
		text

文字列が持つ`replace`関数は、1番目の引数で与えられた正規表現パターンを全て2番目の引数で置換し、新しい文字列として返します。つまり`'Borobudur'.replace(/r/g, 'k')`は`'Bokobuduk'`を返します。パターンのシンタクスについては[正規表現][]で説明しますので、今は気にしないで下さい。
`escapeHTML`では複数の置換を行いますので、それらを配列として用意し、引数に対して一つ一つループで適用してゆくことになります。

ダブルクォーテーションも置換します。なぜならHTMLタグの属性部分のテキストにもこの関数を使うからです。属性はダブルクォーテーションで囲みます。従ってその中にダブルクォーテーションを含んではいけないのです。

`replace`関数を4回呼ぶことは、コンピュータが文字列全体を4回チェックし、その内容を置換しなければいけないことを意味します。これはあまり効率的ではありませんよね。よく考えれば、これをもっと洗練された関数に仕上げることができそうです。先ほど`splitParagraph`関数で見たように、一度だけの実行で置換を済ませてしまうのです。ただ面倒ですので今回はこの作業は行いません。[正規表現][]でこれを実現するための素晴らしいトリックを紹介いたします。

## page 120

---

HTML要素を文字列に変換するには、このように再帰関数を使うことができます。

	renderHTML = (element) ->
		pieces = []
		
		renderAttributes = (attributes) ->
			result = []
			if attributes
				for name of attributes
					result.push ' ' + name + '="' +
						escapeHTML(attributes[name]) + '"'
			result.join ''

		render = (element) ->
			# テキストノード
			if typeof element is 'string'
				pieces.push escapeHTML element
			# 空のタグ
			else if not element.content or
						element.content.length == 0
				pieces.push '<' + element.name +
						renderAttributes(element.attributes) + '/>'
			# 内容のあるタグ
			else
				pieces.push '<' + element.name +
						renderAttributes(element.attributes) + '>'
				forEach element.content, render
				pieces.push '</' + element.name + '>'

		render element
		pieces.join ''

CoffeeScriptオブジェクトからプロパティを抽出している`of`ループに注目してください。ここでHTMLタグに属性を追加しています。また、文字列を蓄積させるために配列を使っている場面が2箇所あります。それぞれ配列の中身が結合され、一つの文字列になるのです。空の文字列に、内容を順次`+=`演算子で追加してゆくというシンプルな方法を採らないのは何故でしょうか？

それは新しい文字列－特に大きな文字列－を生成するのは、とてもコストのかかる作業だからです。CoffeeScriptでは、文字列が決して変化しないということを思い出してください。文字列に何かを連結させる際、そこでは新しい文字列が生成され、元の文字列はそっくりそのまま残っているのです。小さな文字列を沢山連結して大きな文字列を作ろうとすれば、その連結過程で、次の文字列を連結するためだけにその都度新しい文字列が生成されてしまいます。逆に小さな文字列を全て配列の中に収めて、それらをjoinする方法であれば、一つの大きな文字列を生成するだけで済むのです。

## page 121

---

さあ、HTML生成システムを実際に動かしてみましょう。

	show renderHTML link 'http://www.nedroid.com',
						'お絵描き！'	

これは問題なく動くはずです。

	body = [tag('h1', ['The Test']),
			tag('p', ['ここに段落と画像が来ます…']),
	image('../img/ostrich.jpg')]
	doc = htmlDoc 'テスト', body
	show renderHTML doc
	# `stopServer()` とタイプするかCtrl-Cを押して終了します。
	viewServer renderHTML doc

ここで、この方法が不完全なものであるということを指摘しておかなければいけません。この方法では、HTMLに似ていますがもう少し構造的なXMLというものがレンダリングされます。上で見たようなシンプルなケースでは、問題にはなりません。しかし幾つかの要素の中で、XMLとしては正しいものの適切なHTMLではないものがあり、それらが入ったドキュメントを表示させようとすると、ブラウザが正常に動作しないこともあります。例えば空の`script`タグ（ページ内にJavaScriptを入れるためのタグ）がドキュメント内にある場合、ブラウザはそれが空であると理解できず、そのタグ以降のテキストを全てJavaScriptであると判断してしまいます。（この場合、タグの中にスペースを一つ挿入すれば、それは空タグでなくなり従って閉じタグも正しく解釈され、問題は解決します。） 

## page 122

## 練習問題25

まず`renderFragment`関数を書き、それを利用して`renderParagraph`関数を実装してください。`renderParagraph`は、脚注がすでに取り除かれた段落オブジェクトを引数に取り、その段落オブジェクトの`type`プロパティに基づいて、段落やヘッダなどの正しいHTML要素を作ります。

脚注の参照をレンダリングする際は、この関数を使ってみてください。

	footnote = (number) ->
		tag 'sup',
			[link '#footnote' + number, String number]

`sup`タグはその内容を「上付き(=superscript)」として表示します。つまり他のテキストよりも小さく、文字位置が少し上の部分に表示されます。リンクの参照先は「`#footnote1`」のようになります。「#」を含んだリンクはページ内の「アンカー」を参照し、今回の場合脚注リンクをクリックすればページの下の脚注内容が書かれている部分に飛ぶことになります。

強調パーツには`em`タグが使われ、通常のテキストは余計なタグなしでレンダリングされます。

### 解答

	renderFragment = (fragment) ->
		if fragment.type == 'reference'
			footnote fragment.number
		else if fragment.type == 'emphasised'
			tag 'em', [fragment.content]
		else if fragment.type == 'normal'
			fragment.content

	renderParagraph = (paragraph) ->
		tag paragraph.type,
			map paragraph.content, renderFragment

	show renderParagraph paragraphs[7]

## page 123

さあゴールはもう目の前です。レンダリング関数が必要な要素は、脚注を残すだけとなりました。「`#footnote1`」リンクを機能させるために、全ての脚注にアンカーを付ける必要があります。HTMLでは、アンカーは`a`要素で指定します。これはリンクにも使えます。アンカーには`href`要素ではなく、`name`要素が必要です。

	renderFootnote = (footnote) ->
		anchor = tag "a", [],
			name: "footnote" + footnote.number
		number = "[#{footnote.number}] "
		tag "p", [tag("small",
				[anchor, number, footnote.content])]

そして次の関数は、正しくフォーマットされたファイルとドキュメントのタイトルを与えると、HTMLドキュメントを返します。

	renderFile = (file, title) ->
		paragraphs = map file.split('\n\n'),
					processParagraph
		footnotes = map extractFootnotes(paragraphs),
					renderFootnote
		body = map paragraphs,
					renderParagraph
		body = body.concat footnotes
		renderHTML htmlDoc title, body

	page = renderFile recluseFile, 'The Book of Programming'
	show page
	# `stopServer()` とタイプするかCtrl-Cを押して終了します。
	viewServer page

配列は`concat`メソッドで他の配列をつなげることができます。文字列に対して＋演算を行うのと同じですね。

---

以降の章では、基礎的な高階関数として、Underscoreライブラリに収められている`map`および`reduce`をコードサンプルで頻繁に使うことになります。この他にも、便利なツールを随時紹介し説明・使用してゆくことになります。[モジュラー性][]では、これらの「ベーシックな」関数に対して、より構造的なアプローチで迫ってゆきます。

---

## page 124

Pureなどの幾つかの関数型プログラミング言語では、`foldl (+) 0 (1..10)`のように書くことができます。CoffeeScriptでは同じ処理を`reduce [1..10], ((a, b) -> a + b), 0`と書きます。これをコンパクトに書くには、演算子を文字列で表現し、それをインデックスとしたオブジェクトを定義するというやり方があります。

	op = {
			'+': (a, b) 	-> a + b
			'==': (a, b) 	-> a == b
			'!': (a) 		-> !a
			# and so on
		}
	show reduce [1..10], op['+'], 0

しかしこれでは演算子のリストは膨大な量になります。このようなデータ構造が、果たして可読性の向上につながるかどうかは疑問です。逆に次のように書いてみるのはどうでしょうか。

	add = (a, b) -> a + b
	show reduce [1..10], add, 0

更に、引数の一方がすでに値を持っているような`equals`や`makdAddFunction`のような関数を作りたい場合はどうでしょう？このような場合には、改めて新しい関数を作ってみましょう。

ここで「部分適用」という概念が役に立ちます。引数の幾つかの値がすでに分かっており、それらの固定引数に続けて追加の引数を渡す、そういった関数を新しく作ってみましょう。単純に書いてしまえば次のようになります。

	partial = (func, a...) ->
		(b...) -> func a..., b...

	f = (a,b,c,d) -> show "#{a} #{b} #{c} #{d}"
	g = partial f, 1, 2
	g 3, 4

`partial`の戻り値は、引数`a...`が適用済みの関数となります。こうして得られた関数は`b...`を引数に与えると実行できますが、この引数は実際には`func`の引数リストに追加されることになります。

	equals10 = partial op['=='], 10
	show map [1, 10, 100], equals10

伝統的な関数定義と異なり、Underscoreは実行前に引数の順番を配列として定義します。従って次のように単純に書くことはできません。

## page 125

	square = (x) -> x * x
	show map [[10, 100], [12, 16], [0, 1]],
		partial map, square # 正しくありません

何故なら`square`は、内部`map`の2番目の引数でなければいけないからです。ですので、ここで引数の順序を逆にする`partial`をもう一つ作ってみましょう。

	partialReverse = (func, a) -> (b) -> func b, a

	mapSquared = partialReverse map, square
	show map [[10, 100], [12, 16], [0, 1]], mapSquared

しかしここでも、プログラムの意図が、関数を直接定義した時よりも明瞭になっているのかどうかを十分に考慮する必要があります。

	show map [[10, 100], [12, 16], [0, 1]],
		(sublist) -> map sublist, (x) -> x * x

---

関数を繋げたいときは、関数合成を行うことをお勧めします。この章の始めに、関数`negate`を紹介しました。これは真偽値型の`not`演算子を関数の呼び出し結果に適用するものです。

	negate = (func) ->
		(args...) -> not func args...

これは、一般的なパターンの特殊例となります。関数Aを呼び出し、その結果に関数Bを適用します。合成は数学上の共通概念です。高階関数において、合成は次のように実現できます。

	compose = (func1, func2) ->
		(args...) -> func1 func2 args...

	isUndefined = (value) -> value is undefined
	isDefined = compose ((v) -> not v), isUndefined
	show 'isDefined Math.PI = ' + isDefined Math.PI
	show 'isDefined Math.PIE = ' + isDefined Math.PIE

`isDefined`関数では、名前を付けることなく新しい関数を定義しています。これは`map`や`reduce`などに渡す簡単な関数を作りたい時に使う手法です。ただし、関数がこの例よりも複雑になってきた場合には、関数にきちんと定義して名前を付けてやったほうが、コードはより短くそして簡潔になります。

---
---

## 不明な点
1. 71行目 ノンプログラマに理解できるか？

## 外部リンク
* [データ構造]
* [モジュラー性]
* [オブジェクト指向]
* [関数]
* [正規表現]

## 画像
* 231行目: ![figure img/html.png](../img/html.png?raw=true)
---
